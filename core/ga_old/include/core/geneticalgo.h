/********************************************************************************
 *  SALSA Genetic Algorithm Library                                             *
 *  Copyright (C) 2007-2009 Gianluca Massera <emmegian@yahoo.it>                *
 *                                                                              *
 *  This program is free software; you can redistribute it and/or modify        *
 *  it under the terms of the GNU General Public License as published by        *
 *  the Free Software Foundation; either version 2 of the License, or           *
 *  (at your option) any later version.                                         *
 *                                                                              *
 *  This program is distributed in the hope that it will be useful,             *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of              *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
 *  GNU General Public License for more details.                                *
 *                                                                              *
 *  You should have received a copy of the GNU General Public License           *
 *  along with this program; if not, write to the Free Software                 *
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  *
 ********************************************************************************/

#ifndef GENETICALGO_H
#define GENETICALGO_H

#include "gaconfig.h"
#include "parametersettable.h"
#include <QVector>

namespace salsa {

class Genotype;
class Genome;
class Evaluation;
class GeneticAlgo;

/*! \brief Interface for saving/loading data generated by GeneticAlgo
 *
 *  During the evolution process implemented by a subclass of GeneticAlgo a lot
 *  of data will be generated. This class represent the interface that the delegate
 *  object for saving/loading the generate data on files has to implemented.
 *
 *  \ingroup ga_core
 */
class SALSA_GA_API GeneticAlgoIODelegate {
public:
	/*! called at the end of each generation to save data
	 *  \param ga is the GA requesting to saveData
	 */
	virtual void saveData( GeneticAlgo* /*ga*/ ) { }
	/*! called to recover data from an interrupted previous running
	 *  \param ga is the GA requesting the recovering
	 */
	virtual void recoverData( GeneticAlgo* /*ga*/ ) { };
};

/*! \brief An observer interface called during GeneticAlgo operations
 *
 *  Subclass it and implements the method accordlying on what you need to be notified
 * \ingroup ga_core
 */
class SALSA_GA_API GeneticAlgoObserver {
public:
	//! virtual destructor
	virtual ~GeneticAlgoObserver() { };
	//! \brief called at the end of each generation
	virtual void onEndGeneration() { };
};

/*! \brief Genetic Algorithm Common Interface
 *
 *    Interface of the Genetic Algorithm Process<br>
 *    This class is highly abstract and there is no methods here for setting
 *    Selection, Crossover, Mutation and Reproduction processes in order to allow
 *    to each sub-class to choose which subset of operator to use.<br>
 *    Hence, it would be possible to create a GA which allow to specify only Mutation
 *    and fix the other in some pre-determined ways.
 *
 * \ingroup ga_core
 */
class SALSA_GA_API GeneticAlgo : public ParameterSettableWithConfigureFunction {
public:
	/*! Constructor */
	GeneticAlgo( );
	/*! Destructor */
	virtual ~GeneticAlgo();
	/*! return the UI Manager for accessing to the viewers of GeneticAlgo */
	ParameterSettableUI* getUIManager();
	/*! add the observer to the list of current observers */
	void addObserver( GeneticAlgoObserver* observer );
	/*! remove the observer from the list of current observers */
	void removeObserver( GeneticAlgoObserver* observer );
	/*! Initialize the Genetic Algorithm Process
	 *
	 *  In order to create specific Algorithms, re-implement this method
	 */
	virtual void initialize() = 0;
	/*! Execute a single minor step and return
	 *
	 *  In order to create specific Algorithms, re-implement this method
	 */
	virtual void gaStep() = 0;
	/*! Finalize the Genetic Algorithm Process
	 *
	 *  In order to create specific Algorithms, re-implement this method
	 */
	virtual void finalize() = 0;
	/*! Evolve Genome until reach the generation specified. This function exists
	 *  after haveing evaluated individuals of the generationToReach generation
	 *  \warning this method is <b>Blocking</b>
	 */
	void evolve( unsigned int generationToReach );
	/*! Evolve Genome until condition isEvolutionEnded has been reached
	 *  \warning this method is <b>Blocking</b>
	 */
	void evolve();
	/*! returns true if the evolution process has reached the end */
	bool isEvolutionEnded();
	/*! returns true if we have evaluated genomes for the current generation */
	bool isEvaluationDone();
	/*! Set the Genome to use as current population */
	void setGenome( Genome* gen );
	/*! Return the current Genome */
	Genome* genome();
	/*! Return the current Genome */
	const Genome* genome() const;
	/*! Returns the Evaluation object used as prototype to eventually generate
	 *  other evaluators. This object could or could not be used to compute
	 *  the fitness of genotypes (depending on the specific genetic algorithm)
	 */
	virtual Evaluation* evaluationPrototype() = 0;
	/*! Return the Evaluation Pool containing the Evaluations effectively used
	 *  during evolution
	 */
	virtual QVector<Evaluation*> evaluationPool() = 0;
	/*! Set the generation number
	 *  \warning be careful on when you use this function. If you set the generation when
	 *           isEvaluationDone() is true, the next generation to be evaluated will be
	 *           gen + 1
	 */
	void setGeneration( unsigned int gen );
	/*! Return the current generation number */
	unsigned int generation() const;
	/*! Set the number of Generations to do */
	void setNumGenerations( int g );
	/*! Return the number of Generations */
	int numGenerations();
	/*! Skip the evaluation phase and put the algorithm in the state just after
	 *  the evaluation. This can be used after restarting an interrupted evolution
	 *  to prevent re-evaluation of the genome that was loaded from file.
	 */
	virtual void skipEvaluation() = 0;
	/*! Return the Best objective values over generation done
	 *  \warning each entry of the vector contains a vector of max values for each objective,
	 *           but it does not means that exists a genotype scoring all values for all objectives
	 */
	QVector< QVector<double> > bestFits() const;
	/*! Return the Average objective values over generation done */
	QVector< QVector<double> > averageFits() const;
	/*! Return the Mean of Hamming distance over generation done */
	QVector<double> meanHammingDist() const;
	/*! Return the Variance of Hamming distance over generation done */
	QVector<double> varianceHammingDist() const;
	/*! Return the Standard Deviation of Hamming distance over generation done */
	QVector<double> standardDeviationHammingDist() const;
	/*! Set the GeneticAlgoIODelegate to use
	 *  \warning it will not take the owership, so it will be no destroyed by the GeneticAlgo object
	 */
	void setIODelegate( GeneticAlgoIODelegate* iodelegate );
	/*! Return the current GeneticAlgoIODelegate */
	GeneticAlgoIODelegate* getIODelegate() const;

protected:
	/*! Update statistical data of current generation and Genome (Mean, Variance, Standard Deviation)
	 *
	 *  This method should be called by the user when it re-implement GeneticAlgo just afert the evaluation
	 *  of all Genotypes in the Genome
	 *  \warning remember to call it at the right moment, otherwise you will have wrong statistic data
	 */
	void updateStats();

	/*! setted by implementors to signal the finish of evolution process<br>
	 *  when true means that evolution is ended
	 */
	bool evolutionEnd;

	/*! setted by implementors to signal that genomes have been evaluated<br>
	 *  when true means that the genomes of the current generation have been
	 *  evaluated (we are at the end of the end of the generation, next step
	 *  will be reproduction and start of a new generation), when false
	 *  means that genomes haven't still not been evaluated (we are at the
	 *  beginning of a generation, next step will be evaluation of genomes)
	 */
	bool evaluationDone;
	
	/*! notify that a generation has been done */
	void notifyEndGeneration();

	/*! current genome */
	Genome* genomev;
	/*! current generation */
	unsigned int generationv;
	/*! number of generations */
	unsigned int numGens;

	/*! Statistical Data: report the Best value for each objective for each generation */
	QVector< QVector<double> > bestfits;
	/*! Statistical Data: report the Average value for each objective for each generation */
	QVector< QVector<double> > avgfits;
	/*! Statistical Data: report the mean of all hamming distance between genotypes for each generation */
	QVector<double> meanHdists;
	/*! Statistical Data: report the variance of all hamming distance between genotypes for each generation */
	QVector<double> varHdists;
	/*! Statistical Data: report the standard variation of all hamming distance between genotypes for each generation */
	QVector<double> stdHdists;
	
	/*! the IODelegate */
	GeneticAlgoIODelegate* iodelegate;
	/*! the List of Observers */
	QList<GeneticAlgoObserver*> observers;
};

} // end namespace salsa

#endif
